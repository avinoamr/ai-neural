<!DOCTYPE html>
<html>
<head>
    <style>
    body {
        margin-top: 50px;
    }

    .neuron {
        width: 20px;
        min-width: 20px;
        max-width: 20px;
        height: 20px;
        border: 1px solid black;
        border-radius: 50%;
        margin: 10px;
    }

    .neuron.active {
        background: green;
    }

    .layer {
        display: flex;
        /*width: 500px;*/
        /*margin: 0 auto;*/
    }
    </style>
</head>
<body>
    <input id="input" type="text"></input>
    <button id="advance">Advance</button>
    <input id="output" type="text" disabled></input>
    <button id="reward">Reward</button>
    <script>
    function intToNeurons(c) {
        var neurons = [0, 0, 0, 0, 0, 0, 0, 0]
        for (var i = 7; i >= 0; i--) {
            neurons[i] = (c & 1) ? 1 : 0
            c >>= 1
        }

        return neurons
    }

    function neuronsToInt(n) {
        var c = 0
        for (var i = 0; i < 8; i++) {
            c <<= 1
            c |= n[i]
        }
        return c
    }

    function fn(n, ds) {
        var charIdx = Math.floor((n.idx - 1) / 8)
        var bitIdx = (n.idx - 1) % 8
        var charCode = 'hello'.charCodeAt(charIdx)
        return intToNeurons(charCode)[bitIdx]
    }

    var neurons = [
        { idx: 01, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 02, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 03, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 04, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 05, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 06, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 07, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 08, layer: 1, state: false, synapses: [], fn: fn },

        { idx: 09, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 10, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 11, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 12, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 13, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 14, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 15, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 16, layer: 1, state: false, synapses: [], fn: fn },

        { idx: 17, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 18, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 19, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 20, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 21, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 22, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 23, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 24, layer: 1, state: false, synapses: [], fn: fn },

        { idx: 25, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 26, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 27, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 28, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 29, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 30, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 31, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 32, layer: 1, state: false, synapses: [], fn: fn },

        { idx: 33, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 34, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 35, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 36, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 37, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 38, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 39, layer: 1, state: false, synapses: [], fn: fn },
        { idx: 40, layer: 1, state: false, synapses: [], fn: fn },
    ]

    render(neurons)

    // advance the thought processes, evaluating PRNs for all neurons
    function advance() {
        for (var n of neurons) {
            let fn = n.fn || (() => n.state)
            n.state = fn(n, dendritesOf(n))
        }

        var start = 0
        var out = ''
        for (var start = 0; start < neurons.length; start += 8) {
            var n = neurons.slice(start, start + 8).map((n) => n.state)
            var c = neuronsToInt(n)
            out += String.fromCharCode(c)
        }

        return out
    }

    function dendritesOf(n) {
        var dendrites = []
        for (var n0 of neurons) {
            for (var s of n0.synapses) {
                if (s.i == n.idx) {
                    dendrites.push(n0.state)
                }
            }
        }
        return dendrites
    }

    document.querySelector('#advance').addEventListener('click', function () {
        document.querySelector('#output').value = advance()
    })

    // pattern reconition neuron. Boolean function determines if the provided
    // neuron id should fire or not.
    function prn(neuronId) {
        // find all of the dendrites for this neuron
        var dendrites = neurons.reduce((dendrites, n) => {
            for (var s of n.synapses) {
                if (s.i != neuronId) {
                    continue // doesn't belong to this neuron
                }

                s.S = n.state ? 1 : 0
                dendrites.push(s)
            }
            return dendrites
        }, [])

        return true // always fire
    }

    function f(dendries) {
        var N = dendries.reduce((n, d) => Math.max(d.S, n), -Infinity)
        var S = dendries.reduce((n, d) => d.S + n, 0)
        var Max = 0.1 * N + 0.5
        var Min = 1 - Max

        // var f1 = Min + (Max - Min) / S

        console.log((Max - Min) / S)
    }

    document.querySelector('#reward').addEventListener('click', function () {
        var target = neurons[2]

        target.T *= 0.8
        var charge = 2 - 2 * target.T

        // count how many lit synapses are connected to us?
        var incoming = []
        for (var n of neurons) {
            if (!n.state) {
                continue
            }

            for (var s of n.synapses) {
                if (neurons[s.i] == target) {
                    incoming.push(s)
                }
            }
        }

        for (var s of incoming) {
            s.P = charge / incoming.length
        }

        console.log('REWARD. REWIRE')
    })

    function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min
    }

    function render(neurons) {
        // create a domElement for each neuron
        for (var n of neurons) {
            n.domElement = document.createElement('div')
            n.domElement.className = 'neuron'
            n.domElement.addEventListener('click', (function (n) {
                return function() {
                    n.state = !n.state
                }
            })(n))
        }

        // group neurons by layers
        var layers = []
        for (var n of neurons) {
            if (!layers[n.layer]) {
                layers[n.layer] = []
                layers[n.layer].domElement = document.createElement('div')
                layers[n.layer].domElement.className = 'layer'
                document.body.appendChild(layers[n.layer].domElement)
            }

            layers[n.layer].push(n)
            layers[n.layer].domElement.appendChild(n.domElement)
        }

        function update() {
            for (var n of neurons) {
                n.domElement.classList.toggle('active', n.state)
            }
            requestAnimationFrame(update)
        }

        update()
    }

    function g(mean, stdev) {
        var y2;
        var use_last = false;
        return function() {
            var y1;
            if(use_last) {
               y1 = y2;
               use_last = false;
            }
            else {
                var x1, x2, w;
                do {
                     x1 = 2.0 * Math.random() - 1.0;
                     x2 = 2.0 * Math.random() - 1.0;
                     w  = x1 * x1 + x2 * x2;
                } while( w >= 1.0);
                w = Math.sqrt((-2.0 * Math.log(w))/w);
                y1 = x1 * w;
                y2 = x2 * w;
                use_last = true;
           }

           return mean + stdev * y1;
       }
    }

    function stat(fn, n) {
        n = n || 50000
        var s = 0; c = 0
        var max = -Infinity
        var min = +Infinity
        for (var i = 0; i < n; i++) {
            var v = fn(Math.random())
            max = Math.max(max, v)
            min = Math.min(min, v)
            s += v
            c += 1
        }

        var avg = s / c
        return { max, min, avg }
    }

    </script>
</body>
</html>
